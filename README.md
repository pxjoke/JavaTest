# JavaTest  
#####1.Какова разница между абстрактным классом и интерфейсом?  
Интерфейс может содержать только объявления методов (только public) и константы, объявленные как static final. Абстрактный класс может содержать реализацию методов и поля. Если какой-то метод является абстрактным, то и весь класс считается абстрактным.  Концепция позволяет сокрыть внутреннюю реализацию объекта, предоставив только внешний API, не привязанный к конкретной реализации. Интерфейсы накладывают более строгие требования, нежели абстрактные классы ( в них присутствуют только объявления методов (до Java 8)). В языке Java классы могут имплементировать множество интерфейсов, однако наследоваться могут только от одного класса.  
#####2. Как «насильно» вызвать сборку мусора?  
Командой System.gc, однако этого делать не рекомендуется. Эта команда не гарантирует, что сборка мусора начнется сразу после запроса.   
#####3. Когда требуется явное приведение классов?  
Когда мы хотим использовать методы конкретной реализации объекта, созданного через имя интерфейса или более общего класса. Например,  при создании компаратора, он может принимать ссылки на Object или на какой –то общий класс или интерфейс, далее мы пробуем привести его к конкретному типу.  
#####4. Чем конструкторы отличаются от других методов?
Конструкторы занимаются созданием объектов, они выполняют ряд действий по выделению памяти итд. Для программиста основное отличие заключается в том, что конструкторы не возвращают значение. Этим занимается оператор new.  Поэтому иногда приоритет отдается специальному статическому методу, который занимается созданием объекта. Например, он может возвращать ссылку на интерфейс или абстрактный класс, чтобы скрыть конкретную реализацию. Также, если в конструкторе происходит исключительная ситуация, объект создан не будет. 
#####5. Можно ли вызывать конструкторы один из другого, если их в классе несколько?
Да можно, используя ссылку на this. this(params). Это может использоваться для того, чтобы создавать конструкторы, например с различным количеством параметров. Но внутри него вызывать другой конструктор, тем самым предотвращая копирование кода.
#####6. В чем разница между JDK и JRE?
JDK – Java Development Kit – содержит набор библиотек языка Java, компилятор и виртуальную машину. А также ряд утилит для разработчика, например jvisualvm, которая позволяет графически оценивать состояние ВМ.  JRE – Java Runtime Environment – набор средств для запуска программ Java (ВМ и стандартные библиотеки).
#####7. Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
Имеет значение, ведь FileNotFoundException является наследником IOExceptipon. Если первым перехватывать IOExceptipon, то, когда будет происходить обход блоков catch, сработает оператор instanceof и мы попадем в блок обработки IOExceptipon, не обращая при этом внимания на блок catch FileNotFoundException. 
#####8. Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?
Могут, и более того, они могут получить доступ к полям обрамляющего класса.
#####9. Как подкласс может обратиться к методу или конструктору из суперкласса?
Объект класса неявным образом содержит ссылку на объект своего родителя. Используя ключевое слово super, мы можем получить к нему доступ.
#####10. В чем разница между очередью и стеком?
Очередь (First In  First Out, FIFO). Первый попавший элемент, будет первым извлечен. Стек (Last In First Out, LIFO). Последний попавший элемент, будет извлечен первым. Стек устроен так, что элементы мы достаем из конца (tail), а в очереди – из начала (head).
#####11. Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?
В голову приходит принцип работы сборщика мусора. В JVM может быть реализовано множество разных алгоритмов уборки мусора, для разных нужд. По статистике, большинство создаваемых объектов, становятся не нужны буквально сразу-же после создания. Молодые объекты умирают рано. Сборщик разделяет две области памяти: поменьше - young generation, побольше - old generation. Вновь созданный объект попадает YG, тогда как в OG попадают объекты, пережившие по крайней мере одну сборку мусора. В YG действует более быстрый алгоритм очистки. Из одной области памяти живые объекты копируются в другую, старые объекты попадают в OG, далее память полностью очищается (за исключением того участка, куда производилось копирование). В OG действует более медленный алгоритм. Сначала объекты помечаются на удаление, потом, помеченные элементы удаляются, а оставшиеся группируются (уплотняются). 
#####12. Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?
Паттерн Наблюдатель. Класс А «подписывается» на определенные события класса B. После совершения события, в классе А будет запущен соответствующий метод-обработчик. 
#####13. Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?
Никакой т.к. по умолчанию классы имеют пакетную видимость.
#####14. Чем отличается статический внутренний класс от просто внутреннего класса?
Статический внутренний класс не имеет доступа к не статическим полям обрамляющего класса (может получить доступ только через объект обрамляющего класса).
#####15. Можно ли обратиться к не-статической переменной из статического метода?
Нельзя, т.к. статические методы присущи классу как объекту и не привязаны к конкретному экземпляру этого класса.
#####16. Какие типы данных есть в Java?
О. Примитивные типы: byte, char, short, int, long, double, float, boolean + ссылка - располагаются в стеке. Ссылочные типы – располагаются в динамической куче. Примитивные типы имеют объекты-обертки, которые расширяют их функционал. Для оберток реализованы методы авто упаковки-распаковки объектов. Выделение памяти в динамической куче – довольно затратная процедура. В таких языках, как С++, создание нового объекта происходит довольно дорого и долго. Однако в языках, использующих сборщик мусора, в частности Java, создание нового объекта в куче не приводит к таким серьёзным затратам, т.к., сборщик постоянно обходит память и следит, чтобы она была готова к быстрому созданию новых объектов. 
#####17. Чем отличаются переопределение (Override) и перегрузка (Overload)?
Override – это переопределение наследником методов родительского класса. Понятие относится к наследованию и полиморфизму. Overload – создание методов с одинаковыми именами, но разным списком параметров. Причем, создание двух методов с одинаковыми именами и списком параметров, но разным типом возвращаемых значений не является перегрузкой и запрещается. 
#####18. Что такое итератор?
Итератор - это паттерн, описанный GoF. Представляет собой интерфейс, позволяющий перебирать элементы списка. В Java в Collections Framework уже реализованы итераторы, например List Iterator, который позволяет переходить на следующий элемент коллекции. Итераторы используются для организации циклов типа For Each. Также итераторы широко используются и в других языках, например C++ STL Vector также имеет итератор.
#####19. Перечислите основные категории исключительных ситуаций.
Error – фатальная ошибка, скорее всего приводящая к краху системы. Например, закончилась свободная помять, или повредился жесткий диск. Exception – проверяемое исключение, например IOException, которое мы обязаны обработать или отправить выше. Runtime Exception – непроверяемое  исключение. Компилятор не будет настаивать на том, чтобы мы проверяли исключения данного типа. Error и Exception наследуются от Throwable, RuntimeException от Exception. 
#####20. Какая разница между throw и throws?
Ключевое слово throws пишется в объявлении метода с перечислением классов исключений. Оно говорит, что ответственность за возможные перечисленные исключительные ситуации, произошедшие внутри метода, несет ответственность тот, кто этот метод вызывает. Ключевое слово throw употребляется, когда мы хотим сгенерировать объект исключения. Например throw new NullPointerException(). 
#####21. Зачем нужен блок finally?
При возникновении исключительной ситуации иногда необходимо произвести некоторые действия, перед выходом из метода. Например, освободить системные ресурсы (дескрипторы файлов, соединения с бд, мониторы, локи). Блок finally сработает даже в том случае, если в блоке  try присутствует слово return. Для освобождения ресурсов начиная с java 7 можно сипользовать синтаксис try-with-resources, который освобождает программиста от рутины закрытия объектов и делает это автоматическая (если ресурс имплементирует интерфейс AutoClosable) . 
#####22. Что такое finalize?
Это метод, который имеет значение, когда сборщик мусора готовит объект к удалению. Если определен метод finalize, то GC поставит объект в специальную очередь. Время от времени будет запускаться поток – финализатор, который будет вызывать этот метод у объектов очереди. finalize используется как «крайняя инстанция», которая позволят перед удалением объекта освободить системные ресурсы. Этот прием используют разработчики библиотек, чтобы уберечь забывчивых программистов от утечки системных ресурсов. Но всецело полагаться на этот метод – не самая лучшая идея, ведь может возникнуть ситуация, когда наш объект попал на очередь финализатора, а программа уже завершила работу. А т.к. GC и многие служебные потоки jvm являются демонами, то ресурсы, потребляемые объектом так и не будут освобождены. Или же, если наш объект очень тяжеловесный, и в нем определен finalize, то GC не сможет удалить его быстро, вначале он должен будет поместить его в очередь, где он будет дожидаться финализатора. Или же, в системе возник недостаток ОП, тогда finalize тоже скорее всего не вызовется, а объекты будут удалены немедленно.  
#####23. Перечислите все виды внутренних классов.
Существуют для сокрытия реализации класса, а также для более понятного и логичного разделения функционала класса. Позволяют внутри класса реализовывать необходимые интерфейсы, не уведомляя об этом внешних потребителей. Например, внутренний класс может имплементировать интерфейс итератор, который будет использоваться ля обхода элементов обрамляющего класса.   
**Нестатические классы** – имеют доступ к полям и методам обрамляющего класса.   
**Статические классы** – имеют доступ к статическим полям и методам обрамляющего класса.  
Локальные классы – могут быть определены в произвольном логическом блоке кода: внутри метода, внутри блока if и т.д. При этом они имеют доступ к локальным переменным логического блока и полям класса.      
**Анонимные классы** – позволяют создавать объекты классов, при этом не создавая имени нового класса. например t = new Thread( new Runnable() {void run(){…}} ). Объекты будут экземплярами класса, производного от указанного или будут имплементировать указанный интерфейс.   
